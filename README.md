# Rudder

Rudder is the rule engine processor and supervisor for the refiner process in the Covalent Network and further it scalably and securely captures block specimens and their respective transformations.

## Install

If [available in Hex](https://hex.pm/docs/publish), the package can be installed
by adding `rudder` to your list of dependencies in `mix.exs`:

  ```elixir
    def deps do
      [
        {:rudder, "~> 0.1.0"}
      ]
    end
  ```

Documentation can be generated with [ExDoc](https://github.com/elixir-lang/ex_doc)
and published on [HexDocs](https://hexdocs.pm). Once published, the docs can
be found at <https://hexdocs.pm/rudder>.

## Block Specimen Transform (avro binary specimen -> json specimen using `Go` binary)

1. Generate transformer plugin / binary.

  ```bash
    git submodule update --init --recursive
    cd rudder/bsp-agent
    git checkout scripts/extractor-with-files
    go build scripts/extractor.go && mv extractor ../evm/
  ```

2. Apply transform rules.

  ```elixir
    iex -S mix

    Erlang/OTP 25 [erts-13.0] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns] [dtrace]
    Generated rudder app
    Interactive Elixir (1.13.4) - press Ctrl+C to exit (type h() ENTER for help)

 iex(3)> Rudder.build_sync("rules/rules.json")
%{
  "args" => "--binary-file-path './test-data/' --codec-path './priv/schemas/block-ethereum.avsc' --indent-json 0 --output-file-path './out/block-results/'",
  "exec" => "./evm/extractor",
  "input" => "./bin/block-specimens/",
  "output" => "./out/block-results/",
  "rule" => "./evm/extractor --binary-file-path './test-data/' --codec-path './priv/schemas/block-ethereum.avsc' --indent-json 0 --output-file-path './out/block-results/'"
}
%Porcelain.Result{
  err: nil,
  out: "bsp-extractor command line config:  [binary-file-path:\"./test-data/\" codec-path:\"./priv/schemas/block-ethereum.avsc\" indent-json:\"0\" output-file-path:\"./out/block-results/\"]\n\nfile:  out/block-results/1-15127599-replica-0x167a4a9380713f133aa55f251fd307bd88dfd9ad1f2087346e1b741ff47ba7f5-specimen.json bytes:  1563265\n\nfile:  out/block-results/1-15127600-replica-0x14a2d5978dcde0e6988871c1a246bea31e44f73467f7c242f9cd19c30cd5f8b1-specimen.json bytes:  2761078\n\nfile:  out/block-results/1-15127601-replica-0x4757d9272c0f4c5f961667d43265123d22d7459d63f2041866df2962758c6070-specimen.json bytes:  3693996\n\nfile:  out/block-results/1-15127602-replica-0xce9ed851812286e05cd34684c9ce3836ea62ebbfc3764c8d8a131f0fd054ca35-specimen.json bytes:  4492753\n\nfile:  out/block-results/1-15127603-replica-0x5fb7802a8b0f1853bd3e9e8a8646df603e6c57d8da7df62ed46bfec1a6a074c4-specimen.json bytes:  1684665\n",
  status: 0
}
  ```

This should generate the JSON output specimen file (results) to `./out` directory as seen above.

3. View generated/transformed files from binary block specimens

  ```bash
    cd out/block-results
    cat 1-15127599-replica-0x167a4a9380713f133aa55f251fd307bd88dfd9ad1f2087346e1b741ff47ba7f5-specimen.json
  ```

## Block Specimen Concurrent Extractor (`Elixir` native)

1. In the above process we used a sync method to extract all the files in a given directory using a binary generated by Go code

2. Here we extract the files directly async by using a file stream, spawing a decode process for each file separately and using the AVRO library `avrora`

3. It is tested internally with the following steps ()
  a. reads a binary block specimen file
  b. starts the avro client
  c. decodes to json map using the `decode_plain` avrora fn
  d. streams the binary files (does it async - during stream execution)

```elixir

iex(4)> iex(3)> Rudder.Avro.DecodeBlockSpecimen.decode_file("test-data/1-15127599-replica-0x167a4a9380713f133aa55f251fd307bd88dfd9ad1f2087346e1b741ff47ba7f5")
[debug] reading schema `block-ethereum` from the file /Users/pranay/Documents/covalent/elixir-projects/rudder/priv/schemas/block-ethereum.avsc
{:ok,
 %{
   "codecVersion" => 0.2,
   "elements" => 1,
   "endBlock" => 15127599,
   "replicaEvent" => [
     %{
       "data" => %{
         "Hash" => "0x8f858356c48b270221814f8c1b2eb804a5fbd3ac7774b527f2fe0605be03fb37",
         "Header" => %{
           "baseFeePerGas" => 14761528828.0,
           "difficulty" => 1.1506847309002466e16,
           "extraData" => "SGl2ZW9uIHVzLWhlYXZ5",
           "gasLimit" => 29999972,
           ...
           ..
           .
           
```

4. Please note the above extractor process only extract a single specimen


```elixir

iex(6)> Rudder.Avro.DecodeBlockSpecimen.decode_dir("test-data/*")
[
  #Stream<[
    enum: {:ok,
     <<2, 132, 1, 48, 120, 50, 54, 98, 54, 97, 100, 55, 53, 102,
       52, 50, 57, 49, 102, 52, 50, 102, 99, 100, 57, 51, 101,
       55, 55, 48, 51, 102, 54, 55, 102, 102, 57, 102, 51, 97,
       97, 55, 49, 102, 97, 53, ...>>},
    funs: [#Function<47.127921642/1 in Stream.map/2>]
  ]>,
  #Stream<[
    enum: {:ok,
     <<2, 132, 1, 48, 120, 56, 102, 56, 53, 56, 51, 53, 54, 99,
       52, 56, 98, 50, 55, 48, 50, 50, 49, 56, 49, 52, 102, 56,
       99, 49, 98, 50, 101, 98, 56, 48, 52, 97, 53, 102, 98, 100,
       51, 97, 99, ...>>},
    funs: [#Function<47.127921642/1 in Stream.map/2>]
  ]>,
  #Stream<[
    enum: {:ok,
     <<2, 132, 1, 48, 120, 57, 49, 49, 57, 50, 56, 57, 102, 99,
       54, 97, 52, 97, 48, 99, 50, 98, 52, 48, 52, 48, 49, 57,
       100, 55, 101, 49, 54, 97, 55, 101, 56, 53, 48, 53, 57, 48,
       102, 51, ...>>},
    funs: [#Function<47.127921642/1 in Stream.map/2>]
  ]>,
  #Stream<[
    enum: {:ok,
     <<2, 132, 1, 48, 120, 57, 56, 100, 52, 52, 97, 101, 101, 54,
       97, 97, 97, 99, 49, 53, 50, 101, 53, 51, 102, 53, 51, 52,
       54, 51, 55, 53, 56, 100, 97, 99, 56, 54, 101, 53, 57, 54,
       49, ...>>},
    funs: [#Function<47.127921642/1 in Stream.map/2>]
  ]>,
  #Stream<[
    enum: {:ok,
     <<2, 132, 1, 48, 120, 98, 51, 48, 51, 101, 50, 97, 57, 99,
       50, 53, 56, 99, 97, 57, 49, 55, 54, 101, 98, 57, 48, 57,
       52, 98, 51, 49, 57, 100, 53, 50, 55, 98, 51, 49, 54, 52,
       ...>>},
    funs: [#Function<47.127921642/1 in Stream.map/2>]
  ]>
]

```

5. A stream of specimens files can be passed instead to the avro decode process for lazy eval and further down the pipeline to the EBE (erigon t8n tool) processor

## Block Specimen Session Event Listener

In order to run the listener you need to fork ethereum node, run a script to add the operators and a script that mocks block specimen submissions and session finalizations using the docker:

1. Add `.env` file.

2. Inside `.env` add ERIGON_NODE variable and replace the node's url with yours:

```bash
export ERIGON_NODE="erigon.node.url"
```

3. Inside a terminal got to the rudder folder and run: 

```bash
docker compose --env-file ".env" -f "docker-compose-local.yml" up --remove-orphans
```

4. Inside a separate terminal run:

```bash
docker exec -it eth-node /bin/sh  -c "cd /usr/src/app; npm run docker:run";
```

5. Inside a third terminal navigate to the `rudder` folder and run:

```elixir
iex -S mix 
Rudder.ProofChain.BlockSpecimenEventListener.start()
```

## ProofChain Contract Interactor

In order to run the interactor you need to fork ethereum node and run a script to add the operators using the docker:

1. Add `.env` file.

2. Inside `.env` add ERIGON_NODE variable and replace the node's url with yours:

```bash
export ERIGON_NODE="erigon.node.url"
```

3. Inside a terminal got to the rudder folder and run: 

```bash
docker compose --env-file ".env" -f "docker-compose-local.yml" up --remove-orphans
```

4. Inside a second terminal navigate to the `rudder` folder and run:

```elixir
iex -S mix 
```

then

```elixir
Rudder.ProofChain.Interactor.test_submit_block_result_proof(block_height)
```

or

```elixir
Rudder.ProofChain.Interactor.submit_block_result_proof(chain_id, block_height, block_specimen_hash, block_result_hash, url) 
```
